# -*- coding: utf-8 -*-
"""lstm-multistep-forecast.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WmK_z-vicPN8T6aRerhDTQ6-6RpVvoFV
"""

# 1. Importações
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import tensorflow as tf
from tensorflow.keras import layers, models
from sklearn.preprocessing import MinMaxScaler

# 2. Gerar série temporal fictícia
np.random.seed(42)
dias = np.arange(365)
umidade = np.random.uniform(30, 90, size=365)
pressao = 1015 + 5 * np.sin(2 * np.pi * dias / 365)
vento = np.random.uniform(0, 10, size=365)

temperatura = (
    25 + 10 * np.sin(2 * np.pi * dias / 365)
    - 0.1 * umidade
    + 0.05 * (pressao - 1015)
    - 0.3 * vento
    + np.random.normal(0, 1.5, size=365)
)

df = pd.DataFrame({
    'umidade': umidade,
    'pressao': pressao,
    'vento': vento,
    'temperatura': temperatura
})

# 3. Normalizar dados
scaler = MinMaxScaler()
dados_norm = scaler.fit_transform(df)

# 4. Criar janelas para previsão de múltiplos dias
def criar_janelas_multistep(data, janela=7, futuro=3):
    X, y = [], []
    for i in range(len(data) - janela - futuro + 1):
        X.append(data[i:i+janela])
        y.append(data[i+janela:i+janela+futuro, -1])  # Apenas temperatura
    return np.array(X), np.array(y)

X, y = criar_janelas_multistep(dados_norm, janela=7, futuro=3)

# 5. Dividir treino/teste
split = int(len(X) * 0.8)
X_train, X_test = X[:split], X[split:]
y_train, y_test = y[:split], y[split:]

# 6. Criar modelo LSTM evoluído
model = models.Sequential([
    layers.LSTM(64, return_sequences=True, input_shape=(X_train.shape[1], X_train.shape[2])),
    layers.Dropout(0.2),
    layers.LSTM(32),
    layers.Dense(32, activation='relu'),
    layers.Dense(y_train.shape[1])  # Saída com 3 dias
])

model.compile(optimizer='adam', loss='mse', metrics=['mae'])

# 7. Treinar
history = model.fit(X_train, y_train, epochs=50, validation_split=0.1, verbose=1)

# 8. Avaliar
loss, mae = model.evaluate(X_test, y_test)
print(f'\nErro médio absoluto no teste: {mae:.2f} °C')

# 9. Fazer previsões
y_pred = model.predict(X_test)

# 10. Inverter escala (apenas temperatura)
temperatura_idx = df.columns.get_loc("temperatura")
def desnormalizar_temp(normalizadas):
    temp_col = np.zeros((normalizadas.shape[0], scaler.n_features_in_))
    temp_col[:, temperatura_idx] = normalizadas
    return scaler.inverse_transform(temp_col)[:, temperatura_idx]

y_test_real = desnormalizar_temp(y_test.reshape(-1)).reshape(y_test.shape)
y_pred_real = desnormalizar_temp(y_pred.reshape(-1)).reshape(y_pred.shape)

# 11. Plotar previsões vs reais para os 3 próximos dias
plt.figure(figsize=(12, 6))
for i in range(3):
    plt.plot(y_test_real[:30, i], label=f"Real dia {i+1}")
    plt.plot(y_pred_real[:30, i], '--', label=f"Previsto dia {i+1}")
plt.title("Previsão vs Real - Próximos 3 dias")
plt.xlabel("Amostras")
plt.ylabel("Temperatura (°C)")
plt.legend()
plt.grid()
plt.show()